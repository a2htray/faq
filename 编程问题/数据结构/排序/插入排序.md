# 插入排序

**直接插入排序(Straight Insertion Sort)，时间复杂度为O(n^2)**

> 将一个记录插入到一个已经排好序的列表中，得到一个新的、记录数加1的有序表

![](../images/Insertion-sort-example-300px.gif)

```c
Status InsertionSort(SqList &L) {
    for (i = 2; i <= L.length; ++i) {
        L.r[0] = L.r[i];
        L.r[i] = L.r[i - 1];
        for (j = i - 2; LT(L.r[0].key, L.r[j].key); --j) {
            L.r[j + 1] = L.r[j];
        }
        L.r[j + 1] = L.r[0];
    }
}
```

**折半插入排序(Binary Insertion Sort)，时间复杂度为O(n^2)**

主要是为了查找插入点的下标，减少了关键字比较的次数，而记录的移动次数不变

```c
Status BInsertionSort(SqList &L) {
    for (i = 1; i <= L.length; ++i) {
        L.r[0] = L.r[i];
        low = 1; high = i - 1;
        while (low <= high) {
            mid = (low + high) / 2;
            if (LT(L.r[mid].key, L.r[0].key)) {
                high = mid - 1;
            } else {
                low = mid + 1;
            }
        }
        
        for (j = i - 1; j >= high + 1; --j) {
            L.r[j + 1] = L.r[j];
        }
        
        L.r[high + 1] = L.r[0];
        
    }
}
```



